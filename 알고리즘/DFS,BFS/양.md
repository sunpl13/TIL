# 양(3184)

## 문제

미키의 뒷마당에는 특정 수의 양이 있다. 그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.

마당은 행과 열로 이루어진 직사각형 모양이다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다.

한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다. 마당에서 "탈출"할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.

다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.

맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.

아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.

<br/>
<br/>

## 입력

첫 줄에는 두 정수 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.

다음 R개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다.
<br/>
<br/>

## 출력

하나의 줄에 아침까지 살아있는 양과 늑대의 수를 의미하는 두 정수를 출력한다.
<br/>
<br/>

## 예제 입력 1

6 6<br/>
...#..<br/>
.##v#.<br/>
#v.#.#<br/>
#.o#.#<br/>
.###.#<br/>
...###

<br/>
<br/>

## 예제 출력 1

0 2

<br/>
<br/>

## 예제 입력 2

8 8<br/>
.######.<br/>
#..o...#<br/>
#.####.#<br/>
#.#v.#.#<br/>
#.#.o#o#<br/>
#o.##..#<br/>
#.v..v.#<br/>
.######.

<br/>
<br/>

## 예제 출력 2

3 1

<br/>
<br/>

## 예제 입력 3

9 12<br/>
.###.#####..<br/>
#.oo#...#v#.<br/>
#..o#.#.#.#.<br/>
#..##o#...#.<br/>
#.#v#o###.#.<br/>
#..#v#....#.<br/>
#...v#v####.<br/>
.####.#vv.o#<br/>
.......####.

<br/>
<br/>

## 예제 출력 3

3 5

<br/>
<br/>

## 나의 Solution

```javascript
const readline = require("readline");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
let input = [];
let V = 0;
let O = 0;
let a = 0;
let b = 0; //양,늑대
let n,
  m = 0;
let ch = [];
let arr = [];

let dx = [-1, 1, 0, 0];
let dy = [0, 0, -1, 1];
rl.on("line", function (line) {
  input.push(line);
}).on("close", function () {
  [n, m] = input[0].split(" ").map(Number);
  for (let i = 1; i < input.length; i++) {
    arr.push(input[i].split(""));
  }
  ch = Array.from(Array(n), () => Array(m).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (arr[i][j] !== "#" && ch[i][j] === 0) {
        ch[i][j] = 1;
        dfs(i, j);
        //양이 늑대보다 크면
        if (a > b) {
          b = 0; //늑대를 0으로
        } else {
          //그 외에는 양을 0으로
          a = 0;
        }
        V += b;
        O += a;
        a = 0;
        b = 0;
      }
    }
  }
  console.log(O, V);

  //dfs
  function dfs(x, y) {
    if (arr[x][y] === "o") {
      a++; //양의 수 카운트
    } else if (arr[x][y] === "v") {
      b++; //늑대의 수 카운트
    }
    for (let k = 0; k < 4; k++) {
      let nx = x + dx[k];
      let ny = y + dy[k];

      if (nx < 0 || ny < 0 || nx >= n || ny >= m || arr[nx][ny] === "#" || ch[nx][ny] === 1) continue;
      ch[nx][ny] = 1;

      dfs(nx, ny);
    }
  }
  process.exit();
});
```
