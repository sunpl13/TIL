# 기본적인 리팩터링

## 1. 함수 추출하기

- 반대 : 함수 인라인하기

### Before

```javascript
function printOwing(invoice){
    print Banner();

    let outstanding = calculateOutstanding();

    //세부 사항 출력
    console.log(`고객명 : ${invoice.customer}`);
    console.log(`채무액 : ${outstanding}`);
}
```

<br/>

### After

```javascript
function printOwing(invoice){
    print Banner();

    let outstanding = calculateOutstanding();
    printDetails(outstanding);

    function printDetails(outstanding){
    console.log(`고객명 : ${invoice.customer}`);
    console.log(`채무액 : ${outstanding}`);
    }
}
```

### - 코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 수 없이 많다

- 길이를 기준 => 함수 하나가 한 화면을 넘어가선 안됨
- 재사용성을 기준 => 두 번 이상 사용될 코드는 함수로
- `목적`과 `구현`을 분리하는 방식 => 코드가 무슨 일을 하는지 파악이 어려운 것을 함수로 추출

### - 함수의 길이는 그다지 중요하지 않다.

### - 함수가 짧으면 캐싱하기 쉬워져 컴파일러가 최적화 하는데 유리할 때가 많다.

<br/>

### **함수를 추출하는 순서**

### 1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다.

- `어떻게`가 아닌 `무엇을`하는지가 드러나도록 작성

### 2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여 넣는다.

### 3. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수가 없는지 검사

### 4. 변수를 전부 처리 했다면 컴파일한다.

### 5. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 변경

### 6. 테스트

### 7. 다른 코드에 방금 추출한 코드와 똑같거나 비슷한 코드가 없는지 살핀다.

<br/>

### 값을 반환할 변수가 여러 개라면?

### - 보통 각각을 반환하는 함수 여러 개로 만든다.

### - 중첩 함수로 추출할 수 있더라도 최소한 원본 함수와 같은 수준의 문맥으로 먼저 추출

<br/>
<br/>

## 2. 함수 인라인하기

### Before

```javascript
function getRating(driver) {
  return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
  return driver.numberOfLateDeliveries > 5;
}
```

<br/>

### After

```javascript
function getRating(driver) {
  return driver.numberOfLateDeliveries > 5 ? 2 : 1;
}
```

### - 함수 본문이 이름만큼 명확한 경우가 있을 때,

### - 함수 본문 코드를 이름만큼 깔끔하게 리팩터링할 때가 있을 때 사용

### - 함수 인라인하기를 잘 활용하면 유용한 것만 남기고 나머지는 제거 가능

<br/>

### **함수를 인라인하는 순서**

### 1. 다형 메서드인지 확인

- 서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다.

### 2. 인라인할 함수를 호출하는 곳을 모두 찾는다.

### 3. 각 호출문을 함수 본문으로 교체한다.

### 4. 하나씩 교체할 때마다 테스트한다.

### 5. 함수 정의(원래 함수)를 삭제한다.

<br/>
<br/>

# 3. 변수 추출하기

### Before

```javascript
return (
  order.quantity * order.itemPrice -
  Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
  Math.min(order.quantity * order.itemPrice * 0.1, 100)
);
```

<br/>

### After

```javascript
const basePrice = order.quantity * order.itemPrice;
const quantitiyDiscount =
  Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice + quantitiyDiscount + shipping;
```

<br/>

### - 표현식이 너무 복잡해서 이해하기 어려울 때 지역변수를 활용하면 관리하기가 더 쉽다.

- 중단점이나 상태를 출력하는 문장도 넣을 수 있어 디버깅에도 도움이 된다.

### - 변수 추출을 고려한다 = 표현식에 이름을 붙이고 싶다

<br/>

### 변수 추출하는 순서

### 1. 추출하려는 표현식에 부작용은 없는지 확인한다.

### 2. 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.

### 3. 원본 표현식을 새로 만든 변수로 교체한다.

### 4. 테스트한다.

### 5. 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다.

<br/>
<br/>

# 4. 변수 인라인하기

## 변수 이름이 원래 표현식과 다를바 없을 때 변수를 인라인하라.

### Before

```javascript
let basePrice = anOrder.baseBasePrice;
return basePrice > 1000;
```

<br/>

### After

```javascript
return anOrder.baseBasePrice > 1000;
```

<br/>

### 변수 인라인 하는 순서

### 1. 대입문의 우변에서 부작용이 생지기는 않는지 확인한다.

### 2. 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.

      - 이렇게 하면 변수에 값이 단 한 번만 대입되는지 확인할 수 있다.

### 3. 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다

### 4. 테스트한다.

### 5. 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.

### 6. 변수 선언문과 대입문을 지운다.

### 7. 테스트한다.

<br/>
<br/>

# 5. 함수 선언 바꾸기

### Before

```javascript
function circum(radius) {...}
```

<br/>

### After

```javascript
function circumference(radius) {...}
```

<br/>

### - 이름이 좋으면 함수의 구현 코드를 살펴볼 필요 없이 호풀문만 보고도 무슨 일을 하는지 파악할 수 있다.

### - 주석을 이용해 함수의 목적을 설명해보면 적절한 함수 이름이 생각날 수도 있다.

### - 매개변수는 함수를 사용하는 문맥을 설정

### - 매개변수에 정답은 없으므로 상황에 따라 적절하게 변경할 수 있도록 함수 선언 바꾸기 리팩토링과 친숙해져야 한다.

<br/>

### 함수 선언 바꾸기 간단한 순서

### 1. 매개변수를 제거하려 할 때 함수 본문에서 제거 대상의 매개변수를 참조하는 곳이 없는지 검사

### 2. 메서드 선언을 원하는 형태로 바꾸기

### 3. 기존 메서드 선언을 참조하는 부분도 전부 바꾸기

### 4. 테스트한다.

<br/>

### 함수 선언 바꾸기 마이그레이션 절차

### 1. 함수의 본문을 적절히 리팩토링하기

### 2. 함수 본문을 새로운 함수로 추출

### 3. 추출한 함수에 매개변수를 추가해야 한다면 '간단한 절차'를 따라 추가

### 4. 테스트한다.

### 5. 기존 함수 인라인하기

### 6. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 통해 원래 이름으로 돌리기

### 7. 다시 테스트

<br/>
<br/>

# 6. 변수 캡슐화하기

### Before

```javascript
let defaultOwner = { firstName: "마틴", lastName: "파울러" };
```

<br/>

### After

```javascript
let defaultOwner = { firstName: "마틴", lastName: "파울러" };
export function defaultOwner() {
  return defaultOwnerData;
}
export function setDefaultOwner(arg) {
  defaultOwnerData = arg;
}
```

### 1. 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화 하는 것이 좋다.

<br/>

### 변수 캡슐화하기 절차

### 1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.

### 2. 정적 검사 수행

### 3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 변경

### 4. 변수 접근 범위 제한

### 5. 테스트

### 6. 변수 값이 레코드라면 레코드 캡슐화하기 적용할지 고려

<br/>
<br/>

# 7. 변수 이름 바꾸기

### Before

```javascript
let a = height * width;
```

<br/>

### After

```javascript
let area = height * width;
```

<br/>

### - 변수는 하려는 일에 관해 많은 것을 설명해준다.

### - 변수의 목적이 드러나도록 변수명을 설정

<br/>

### 변수 이름 바꾸기 절차

### 1. 폭 넓게 쓰이는 변수라면 캡슐화하기 고려

### 2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서 하나씩 변경

### 3. 테스트

<br/>
<br/>

# 8. 매개변수 객체 만들기

### Before

```javascript
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}
```

<br/>

### After

```javascript
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

<br/>

### - 데이터 항목 여러개가 함께 몰려다니는 매개변수를 하나로 모은다.

### - 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계까 명확해진다.

### - 매개변수 수가 줄어든다.

<br/>

### 매개변수 객체만들기 절차

### 1. 적당한 데이터구조가 아직 마련되어 있지 않다면 새로 만든다.

    - 필자는 클래스로 만드는 것을 선호 => 동작까지 함께 묶기 좋기 때문

### 2. 테스트

### 3. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가

### 4. 테스트

### 5. 함수 호출 시 새로운 데이터구조 인스턴스를 넘기도록 수정

### 6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾸기

### 7. 다 바꿨다면 기존 매개변수를 제거하고 테스트

<br/>
<br/>

# 9. 여러 함수를 클래스로 묶기

### Before

```javascript
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}
```

<br/>

### After

```javascript
function base() {...}
function taxableCharge() {...}
function calculateBaseCharge() {...}
```

<br/>

### - 클래스로 묶으면 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있다.

### - 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 더 간결하게 만들 수 있다.

<br/>

### 여러 함수 클래스로 묶기 절차

### 1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화

    - 공통 데이커가 레코드 구조로 묶여 있지 않다면 먼저 데이터를 하나로 묶기

### 2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮기기

### 3. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮기기
