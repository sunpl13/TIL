# 코드에서 나는 악취

## 1. 기이한 이름

### **코드를 명료하게 표현하는 데 가장 중요한 요소는 바로 `이름`이다.**

- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약 가능하다.
- **함수 선언 바꾸기**, **변수 이름 바꾸기**, **필드 이름 바꾸기**가 이에 속함
  <br/>

---

## 2. 중복 코드

### 중복 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

1.  **함수 추출하기**로 중복 코드 추출
2.  완전히 같지 않다면 문장 **슬라이드 하기**로 비슷한 부분 한 곳에 모으기
3.  같은 부모로 부터 파생된 서브 클래스에 코드 중복 시 **메서드 올리기**를 적용해서 부모로 옮기기

 <br/>

---

## 3. 긴 함수

### 코드를 위임하는 방식으로 작성

- **무엇을 하는지**를 코드가 설명해주지 못할수록 함수로 만드는 것이 유리
- 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**이다.
- 매개변수 줄이기(**임시 변수를 질의 함수로 바꾸기**, **매개변수 객체 만들기**, **객체 통째로 넘기기**)
- 무엇을 추출할지 모르겠으면 **주석이 있는 부분**을 찾아서 추출하자
- 조건문은 **조건문 분해하기**

<br/>

---

## 4. 긴 매개변수 목록

- **매개변수를 질의로 함수 바꾸기**, **객체 통째로 넘기기**, **매개변수 객체 만들기** 등으로 매개변수 줄이기

<br/>

---

## 5. 전역 데이터

- **전역 데이터**는 절대로 사용하지 말 것!
- **변수 캡슐화**하여 데이터 접근에 대한 통제를 한다.
- 전역 데이라도 **가변**데이터는 되도록 만들지 말자

<br/>

---

## 6. 가변 데이터

- **변수 캡슐화**를 통해서 지정해 놓은 함수를 거쳐야만 값을 수정할 수 있도록 해서 값 수정을 감시
- **변수 쪼개기**를 통해 용도별로 변수를 저장시키기
- **여러 함수를 클래스로 묶기**나 **여러 함수를 변환 함수로 묶기**를 통해 변수를 갱신하는 코드의 유효 범위를 줄이기

<br/>

---

## 7. 뒤엉킨 변경

### 단일 책임 원칙(SPR)이 제대로 지켜지지 않을 시 나타나는 현상

### **단일 책임 원칙** : 모든 클래스는 단 한가지의 책임만을 가지고 클래스 안에 있는 기능들은 하나의 책임을 수행하는데 집중 되어야 한다는 원칙

- 순차적으로 실행되는게 자연스러운 맥락의 프로그램이라면 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하도록 분리
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수 호출 빈도가 높다면 **모듈로 만들어서 관련 함수들을 모은다.**

<br/>

---

## 8. 산탄총 수술

### 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때

- 함께 변경되는 대상들을 **한 모듈에 묶어두기**
- 여러 함수를 **클래스로 묶기**나 **변환 함수로 묶기**를 적용

<br/>

---

## 9. 기능 편애

### 프로그램 모듈화 시에는 영역 안에서 이뤄지는 상호작용은 **최대화**, 영역끼리 이뤄지는 상호작용은 **최소화**

- **함수 추출하기**를 통해 함수를 여러 조각으로 나눈 뒤 적절한 모듈로 옮기기

<br/>

---

## 10. 데이터 뭉치

- 데이터 뭉치를 찾아서 **클래스 추출**로 하나의 객체로 묶기
- 데이터 뭉치인지 판별하려면 값 하나를 삭제 해본다.

<br/>

---

## 11. 기본형 집착

- **기본형을 객체로 바꾸기**

<br/>

---

## 12. 반복되는 switch문

### **조건부 로직을 다형성으로 바꾸면** switch문의 문제점 해결 가능

<br/>

---

## 13. 반복문

### 반복문을 파이프라인으로 바꾸기를 통해 반복문을 제거할 수 있다.

<br/>

---

## 14. 성의 없는 요소

### 요소로서 활용의미가 없어진 요소들은 없애버리는 것도 좋은 방안이다.

- **함수 인라인하기**나 **클래스 인라인하기**등으로 해결

<br/>

---

## 15. 추측성 일반화

### 당장 필요 없는 특이 케이스 처리 로직을 작성해 둘 때 생기는 문제점

- **계층 합치기**를 통해서 제거

<br/>

---

## 16. 임시 필드

### 특정 상황에서만 값이 설정되는 필드는 더 활용성 높게 옮겨준다.

- **클래스 추출하기**와 **함수 옮기기**로 임시 필드와 관련된 코드를 모조리 새 클래스에 넣는다.
- **특이 케이스 추가하기**를 통해 필드가 유효하지 않을 때를 위한 대안 클래스 생성

<br/>

---

## 17. 메시지 체인

> 메시지 체인 : 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드

- **위임 숨기기**로 해결

<br/>

---

## 18. 중개자

- **중개자 제거하기**를 통해 실제로 하는 일을 객체와 직접 하도록 수정

<br/>

---

## 19. 내부자 거래

- **함수 옮기기**와 **필드 옮기기**를 통해 모듈간 데이터 상호작용을 최소화시킨다.
- 모듈들이 같은 데이터를 공유한다면 제 3의 모듈을 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.

<br/>

---

## 20. 거대한 클래스

### 한 클래스가 너무 많은 일을 하지 않게 만들자

- **클래스 추출**을 통해 필드 일부를 따로 묶기
- 클래스 안에서 자체적으로 중복 제거하기

<br/>

---

## 21. 서로 다른 인터페이스의 대안 클래스들

1. **함수 선언 바꾸기**를 통해 메서드 시그니처를 일치 시키기
2. **함수 옮기기**를 이용해서 인터페이스가 같아질 때까지 피룡한 동작들을 클래스로 이동
3. 대안 클래스들 사이에 중복코드가 생기면 **슈퍼 클래스 추출하기**적용 고려

<br/>

---

## 22. 데이터 클래스

> 데이터 클래스 : 데이터 필드와 Getter,Setter 메서드로만 구성된 클래스

- **레코드 캠슐화**로 숨기기
- 변경하면 안되는 필드는 **세터 제거하기**를 통해 접근 제한
- 다른 클래스에서 데이터 클래스의 Getter,Setter를 사용하는 메서드를 찾아서 옮기기

<br/>

---

## 23. 상속 포기

### 일부 독작을 재활용하기 위한 목적으로 상속을 활용하는 것은 실무 관점에서 유용

> 부모의 동작은 필요로 하지만 인터페이스를 따르지 않는다는 것은 무례한 태도

- **서브 클래스를 위임으로 바꾸기**나 **슈퍼 클래스를 위임으로 바꾸기**를 활용해서 상속 매커니즘에서 벗어나자

<br/>

---

## 24. 주석

### 주석이 많은 것은 악취가 심하게 난다는 증거, 즉 코드만 잘 짜면 없어질 주석들이 많다는 얘기

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩토링 해보자
